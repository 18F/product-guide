{"version":3,"file":"filter.js","sources":["../../../src/ol/format/filter.js"],"sourcesContent":["/**\n * @module ol/format/filter\n */\nimport And from './filter/And.js';\nimport Bbox from './filter/Bbox.js';\nimport Contains from './filter/Contains.js';\nimport During from './filter/During.js';\nimport EqualTo from './filter/EqualTo.js';\nimport GreaterThan from './filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\nimport Intersects from './filter/Intersects.js';\nimport IsBetween from './filter/IsBetween.js';\nimport IsLike from './filter/IsLike.js';\nimport IsNull from './filter/IsNull.js';\nimport LessThan from './filter/LessThan.js';\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\nimport Not from './filter/Not.js';\nimport NotEqualTo from './filter/NotEqualTo.js';\nimport Or from './filter/Or.js';\nimport Within from './filter/Within.js';\n\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params));\n}\n\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params));\n}\n\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\n * @returns {!Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../extent.js\").Extent} extent Extent.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, opt_srsName) {\n  return new Bbox(geometryName, extent, opt_srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, opt_srsName) {\n  return new Contains(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, opt_srsName) {\n  return new Intersects(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, opt_srsName) {\n  return new Within(geometryName, geometry, opt_srsName);\n}\n\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, opt_matchCase) {\n  return new EqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @returns {!IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @returns {!IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string=} opt_singleChar pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string=} opt_escapeChar Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(propertyName, pattern,\n  opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n  return new IsLike(propertyName, pattern,\n    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);\n}\n\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @returns {!During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n"],"names":["const"],"mappings":"AAAA;;;AAGA,OAAO,GAAG,MAAM,iBAAiB,CAAC;AAClC,OAAO,IAAI,MAAM,kBAAkB,CAAC;AACpC,OAAO,QAAQ,MAAM,sBAAsB,CAAC;AAC5C,OAAO,MAAM,MAAM,oBAAoB,CAAC;AACxC,OAAO,OAAO,MAAM,qBAAqB,CAAC;AAC1C,OAAO,WAAW,MAAM,yBAAyB,CAAC;AAClD,OAAO,oBAAoB,MAAM,kCAAkC,CAAC;AACpE,OAAO,UAAU,MAAM,wBAAwB,CAAC;AAChD,OAAO,SAAS,MAAM,uBAAuB,CAAC;AAC9C,OAAO,MAAM,MAAM,oBAAoB,CAAC;AACxC,OAAO,MAAM,MAAM,oBAAoB,CAAC;AACxC,OAAO,QAAQ,MAAM,sBAAsB,CAAC;AAC5C,OAAO,iBAAiB,MAAM,+BAA+B,CAAC;AAC9D,OAAO,GAAG,MAAM,iBAAiB,CAAC;AAClC,OAAO,UAAU,MAAM,wBAAwB,CAAC;AAChD,OAAO,EAAE,MAAM,gBAAgB,CAAC;AAChC,OAAO,MAAM,MAAM,oBAAoB,CAAC;;;;;;;;;;AAUxC,OAAO,SAAS,GAAG,CAAC,UAAU,EAAE;EAC9BA,GAAK,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;EACpE,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC;CACzD;;;;;;;;;;AAUD,OAAO,SAAS,EAAE,CAAC,UAAU,EAAE;EAC7BA,GAAK,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;EACpE,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC;CACxD;;;;;;;;;;AAUD,OAAO,SAAS,GAAG,CAAC,SAAS,EAAE;EAC7B,OAAO,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC;CAC3B;;;;;;;;;;;;;;AAcD,OAAO,SAAS,IAAI,CAAC,YAAY,EAAE,MAAM,EAAE,WAAW,EAAE;EACtD,OAAO,IAAI,IAAI,CAAC,YAAY,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;CACpD;;;;;;;;;;;;;AAaD,OAAO,SAAS,QAAQ,CAAC,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE;EAC5D,OAAO,IAAI,QAAQ,CAAC,YAAY,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;CAC1D;;;;;;;;;;;;;AAaD,OAAO,SAAS,UAAU,CAAC,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE;EAC9D,OAAO,IAAI,UAAU,CAAC,YAAY,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;CAC5D;;;;;;;;;;;;;AAaD,OAAO,SAAS,MAAM,CAAC,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE;EAC1D,OAAO,IAAI,MAAM,CAAC,YAAY,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;CACxD;;;;;;;;;;;;AAYD,OAAO,SAAS,OAAO,CAAC,YAAY,EAAE,UAAU,EAAE,aAAa,EAAE;EAC/D,OAAO,IAAI,OAAO,CAAC,YAAY,EAAE,UAAU,EAAE,aAAa,CAAC,CAAC;CAC7D;;;;;;;;;;;;AAYD,OAAO,SAAS,UAAU,CAAC,YAAY,EAAE,UAAU,EAAE,aAAa,EAAE;EAClE,OAAO,IAAI,UAAU,CAAC,YAAY,EAAE,UAAU,EAAE,aAAa,CAAC,CAAC;CAChE;;;;;;;;;;;AAWD,OAAO,SAAS,QAAQ,CAAC,YAAY,EAAE,UAAU,EAAE;EACjD,OAAO,IAAI,QAAQ,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;CAC/C;;;;;;;;;;;AAWD,OAAO,SAAS,iBAAiB,CAAC,YAAY,EAAE,UAAU,EAAE;EAC1D,OAAO,IAAI,iBAAiB,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;CACxD;;;;;;;;;;;AAWD,OAAO,SAAS,WAAW,CAAC,YAAY,EAAE,UAAU,EAAE;EACpD,OAAO,IAAI,WAAW,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;CAClD;;;;;;;;;;;AAWD,OAAO,SAAS,oBAAoB,CAAC,YAAY,EAAE,UAAU,EAAE;EAC7D,OAAO,IAAI,oBAAoB,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;CAC3D;;;;;;;;;;;AAWD,OAAO,SAAS,MAAM,CAAC,YAAY,EAAE;EACnC,OAAO,IAAI,MAAM,CAAC,YAAY,CAAC,CAAC;CACjC;;;;;;;;;;;;;AAaD,OAAO,SAAS,OAAO,CAAC,YAAY,EAAE,aAAa,EAAE,aAAa,EAAE;EAClE,OAAO,IAAI,SAAS,CAAC,YAAY,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC;CAClE;;;;;;;;;;;;;;;;;;;AAmBD,OAAO,SAAS,IAAI,CAAC,YAAY,EAAE,OAAO;EACxC,YAAY,EAAE,cAAc,EAAE,cAAc,EAAE,aAAa,EAAE;EAC7D,OAAO,IAAI,MAAM,CAAC,YAAY,EAAE,OAAO;IACrC,YAAY,EAAE,cAAc,EAAE,cAAc,EAAE,aAAa,CAAC,CAAC;CAChE;;;;;;;;;;;;AAYD,OAAO,SAAS,MAAM,CAAC,YAAY,EAAE,KAAK,EAAE,GAAG,EAAE;EAC/C,OAAO,IAAI,MAAM,CAAC,YAAY,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;CAC7C;"}