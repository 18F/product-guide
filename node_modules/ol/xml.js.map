{"version":3,"file":"xml.js","sources":["../../src/ol/xml.js"],"sourcesContent":["/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n\n/**\n * When using {@link module:ol/xml~makeChildAppender} or\n * {@link module:ol/xml~makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Node} node\n */\n\n\n/**\n * @typedef {function(Element, Array<*>)} Parser\n */\n\n\n/**\n * @typedef {function(Element, *, Array<*>)} Serializer\n */\n\n\n/**\n * This document should be used when creating nodes for XML serializations. This\n * document is also used by {@link module:ol/xml~createElementNS}\n * @const\n * @type {Document}\n */\nexport const DOCUMENT = document.implementation.createDocument('', '', null);\n\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\n\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return DOCUMENT.createElementNS(namespaceURI, qualifiedName);\n}\n\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (node.nodeType == Node.CDATA_SECTION_NODE ||\n      node.nodeType == Node.TEXT_NODE) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n        extend(array, value);\n      }\n    }\n  );\n}\n\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n        array.push(value);\n      }\n    });\n}\n\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    });\n}\n\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string=} opt_property Property.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n        const property = opt_property !== undefined ? opt_property : node.localName;\n        let array;\n        if (property in object) {\n          array = object[property];\n        } else {\n          array = object[property] = [];\n        }\n        array.push(value);\n      }\n    });\n}\n\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string=} opt_property Property.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n        const property = opt_property !== undefined ? opt_property : node.localName;\n        object[property] = value;\n      }\n    });\n}\n\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>)} nodeWriter Node writer.\n * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, opt_this) {\n  return function(node, value, objectStack) {\n    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);\n    const parent = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n    const parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml~serialize}. This can be used by the parent writer to have the\n * 'nodeWriter' called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>)} nodeWriter Node writer.\n * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, opt_this) {\n  let serializersNS, nodeFactory;\n  return function(node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n\n/**\n * Create a node factory which can use the `opt_keys` passed to\n * {@link module:ol/xml~serialize} or {@link module:ol/xml~pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string=} opt_nodeName Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n  const fixedNodeName = opt_nodeName;\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string=} opt_nodeName Node name.\n     * @return {Node} Node.\n     */\n    function(value, objectStack, opt_nodeName) {\n      const context = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = opt_nodeName;\n      }\n\n      const namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml~serialize} or\n * {@link module:ol/xml~pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml~serialize} or\n * {@link module:ol/xml~pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `opt_key` argument.\n * @param {Object<string, V>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<V>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n * @template V\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>=} opt_structureNS Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n  /**\n   * @type {Object<string, T>}\n   */\n  const structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*=} opt_this The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(opt_this, n, objectStack);\n      }\n    }\n  }\n}\n\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*=} opt_this The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, opt_this);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>=} opt_keys Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T=} opt_this The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  const length = (opt_keys !== undefined ? opt_keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack,\n        opt_keys !== undefined ? opt_keys[i] : undefined);\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName]\n          .call(opt_this, node, value, objectStack);\n      }\n    }\n  }\n}\n\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>=} opt_keys Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T=} opt_this The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n"],"names":["const","let"],"mappings":"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"}