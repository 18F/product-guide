{"version":3,"file":"closest.js","sources":["../../../../src/ol/geom/flat/closest.js"],"sourcesContent":["/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(\n      flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(\n      flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end,\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max(\n        ((Math.sqrt(squaredDistance) -\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends,\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates, offset, end, stride,\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset,\n  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates, offset, ends, stride,\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n"],"names":["i","const","let"],"mappings":"AAAA;;;AAGA,QAAQ,IAAI,EAAE,eAAe,IAAI,SAAS,OAAO,eAAe,CAAC;;;;;;;;;;;;;;;AAejE,SAAS,aAAa,CAAC,eAAe,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE;EACpFC,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,OAAO,CAAC,CAAC;EACpCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;EACxCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;EACzCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;EAC7CC,GAAG,CAAC,MAAM,CAAC;EACX,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;IACxB,MAAM,GAAG,OAAO,CAAC;GAClB,MAAM;IACLD,GAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;IAChE,IAAI,CAAC,GAAG,CAAC,EAAE;MACT,MAAM,GAAG,OAAO,CAAC;KAClB,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE;MAChB,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC/B,YAAY,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC;UACjD,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;OACpC;MACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;MAC7B,OAAO;KACR,MAAM;MACL,MAAM,GAAG,OAAO,CAAC;KAClB;GACF;EACD,KAAKA,GAAG,CAACF,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG,MAAM,EAAE,EAAEA,GAAC,EAAE;IAC/B,YAAY,CAACA,GAAC,CAAC,GAAG,eAAe,CAAC,MAAM,GAAGA,GAAC,CAAC,CAAC;GAC/C;EACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;CAC9B;;;;;;;;;;;;;AAaD,OAAO,SAAS,eAAe,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE;EACzEE,GAAG,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;EACjCA,GAAG,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;EACrC,KAAK,MAAM,IAAI,MAAM,EAAE,MAAM,GAAG,GAAG,EAAE,MAAM,IAAI,MAAM,EAAE;IACrDD,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;IACnCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACvCA,GAAK,CAAC,YAAY,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAC/C,IAAI,YAAY,GAAG,GAAG,EAAE;MACtB,GAAG,GAAG,YAAY,CAAC;KACpB;IACD,EAAE,GAAG,EAAE,CAAC;IACR,EAAE,GAAG,EAAE,CAAC;GACT;EACD,OAAO,GAAG,CAAC;CACZ;;;;;;;;;;;AAWD,OAAO,SAAS,oBAAoB,CAAC,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE;EAC/E,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC7CD,GAAK,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;IACpB,GAAG,GAAG,eAAe;MACnB,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IAC7C,MAAM,GAAG,GAAG,CAAC;GACd;EACD,OAAO,GAAG,CAAC;CACZ;;;;;;;;;;;AAWD,OAAO,SAAS,yBAAyB,CAAC,eAAe,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,EAAE;EACrF,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC9CD,GAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtB,GAAG,GAAG,oBAAoB;MACxB,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IAC9C,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;GAChC;EACD,OAAO,GAAG,CAAC;CACZ;;;;;;;;;;;;;;;;;AAiBD,OAAO,SAAS,kBAAkB,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG;EAC7D,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB;EAChE,YAAY,EAAE;EACd,IAAI,MAAM,IAAI,GAAG,EAAE;IACjB,OAAO,kBAAkB,CAAC;GAC3B;EACDC,GAAG,CAAC,CAAC,EAAE,eAAe,CAAC;EACvB,IAAI,QAAQ,KAAK,CAAC,EAAE;;IAElB,eAAe,GAAG,SAAS;MACzB,CAAC,EAAE,CAAC,EAAE,eAAe,CAAC,MAAM,CAAC,EAAE,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAC9D,IAAI,eAAe,GAAG,kBAAkB,EAAE;MACxC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC3B,YAAY,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;OAC/C;MACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;MAC7B,OAAO,eAAe,CAAC;KACxB,MAAM;MACL,OAAO,kBAAkB,CAAC;KAC3B;GACF;EACDD,GAAK,CAAC,QAAQ,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC1DC,GAAG,CAAC,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;EAC5B,OAAO,KAAK,GAAG,GAAG,EAAE;IAClB,aAAa;MACX,eAAe,EAAE,KAAK,GAAG,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;IAClE,eAAe,GAAG,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5D,IAAI,eAAe,GAAG,kBAAkB,EAAE;MACxC,kBAAkB,GAAG,eAAe,CAAC;MACrC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC3B,YAAY,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;OAC/B;MACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;MAC7B,KAAK,IAAI,MAAM,CAAC;KACjB,MAAM;;;;;;;;;;;MAWL,KAAK,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG;QACxB,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC;YACxB,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;KAC1D;GACF;EACD,IAAI,MAAM,EAAE;;IAEV,aAAa;MACX,eAAe,EAAE,GAAG,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;IACjE,eAAe,GAAG,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5D,IAAI,eAAe,GAAG,kBAAkB,EAAE;MACxC,kBAAkB,GAAG,eAAe,CAAC;MACrC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC3B,YAAY,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;OAC/B;MACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;KAC9B;GACF;EACD,OAAO,kBAAkB,CAAC;CAC3B;;;;;;;;;;;;;;;;;AAiBD,OAAO,SAAS,uBAAuB,CAAC,eAAe,EAAE,MAAM,EAAE,IAAI;EACnE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB;EAChE,YAAY,EAAE;EACdD,GAAK,CAAC,QAAQ,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC1D,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC7CD,GAAK,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;IACpB,kBAAkB,GAAG,kBAAkB;MACrC,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM;MACpC,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;IACtE,MAAM,GAAG,GAAG,CAAC;GACd;EACD,OAAO,kBAAkB,CAAC;CAC3B;;;;;;;;;;;;;;;;;AAiBD,OAAO,SAAS,4BAA4B,CAAC,eAAe,EAAE,MAAM;EAClE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB;EACvE,YAAY,EAAE;EACdA,GAAK,CAAC,QAAQ,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC1D,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC9CD,GAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtB,kBAAkB,GAAG,uBAAuB;MAC1C,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM;MACrC,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;IACtE,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;GAChC;EACD,OAAO,kBAAkB,CAAC;CAC3B;"}